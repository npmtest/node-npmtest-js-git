{"/home/travis/build/npmtest/node-npmtest-js-git/test.js":"/* istanbul instrument in package npmtest_js_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-git/lib.npmtest_js_git.js":"/* istanbul instrument in package npmtest_js_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_js_git = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_js_git = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-js-git/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-js-git && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_js_git */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_js_git\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_js_git.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_js_git.rollup.js'] =\n            local.assetsDict['/assets.npmtest_js_git.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_js_git.__dirname + '/lib.npmtest_js_git.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/apply-delta.js":"var bodec = require('bodec');\n\nmodule.exports = applyDelta;\n\nfunction applyDelta(delta, base) {\n  var deltaOffset = 0;\n\n  if (base.length !== readLength()) {\n    throw new Error(\"Base length mismatch\");\n  }\n\n  // Create a new output buffer with length from header.\n  var outOffset = 0;\n  var out = bodec.create(readLength());\n\n  while (deltaOffset < delta.length) {\n    var byte = delta[deltaOffset++];\n    // Copy command.  Tells us offset in base and length to copy.\n    if (byte & 0x80) {\n      var offset = 0;\n      var length = 0;\n      if (byte & 0x01) offset |= delta[deltaOffset++] << 0;\n      if (byte & 0x02) offset |= delta[deltaOffset++] << 8;\n      if (byte & 0x04) offset |= delta[deltaOffset++] << 16;\n      if (byte & 0x08) offset |= delta[deltaOffset++] << 24;\n      if (byte & 0x10) length |= delta[deltaOffset++] << 0;\n      if (byte & 0x20) length |= delta[deltaOffset++] << 8;\n      if (byte & 0x40) length |= delta[deltaOffset++] << 16;\n      if (length === 0) length = 0x10000;\n      // copy the data\n      bodec.copy(bodec.slice(base, offset, offset + length), out, outOffset);\n      outOffset += length;\n    }\n    // Insert command, opcode byte is length itself\n    else if (byte) {\n      bodec.copy(bodec.slice(delta, deltaOffset, deltaOffset + byte), out, outOffset);\n      deltaOffset += byte;\n      outOffset += byte;\n    }\n    else throw new Error('Invalid delta opcode');\n  }\n\n  if (outOffset !== out.length) {\n    throw new Error(\"Size mismatch in check\");\n  }\n\n  return out;\n\n  // Read a variable length number our of delta and move the offset.\n  function readLength() {\n    var byte = delta[deltaOffset++];\n    var length = byte & 0x7f;\n    var shift = 7;\n    while (byte & 0x80) {\n      byte = delta[deltaOffset++];\n      length |= (byte & 0x7f) << shift;\n      shift += 7;\n    }\n    return length;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/config-codec.js":"\"use strict\";\n\n// This is for working with git config files like .git/config and .gitmodules.\n// I believe this is just INI format.\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n\nfunction encode(config) {\n  var lines = [];\n  Object.keys(config).forEach(function (name) {\n    var obj = config[name];\n    var deep = {};\n    var values = {};\n    var hasValues = false;\n    Object.keys(obj).forEach(function (key) {\n      var value = obj[key];\n      if (typeof value === 'object') {\n        deep[key] = value;\n      }\n      else {\n        hasValues = true;\n        values[key] = value;\n      }\n    });\n    if (hasValues) {\n      encodeBody('[' + name + ']', values);\n    }\n\n    Object.keys(deep).forEach(function (sub) {\n      var child = deep[sub];\n      encodeBody('[' + name + ' \"' + sub + '\"]', child);\n    });\n  });\n\n  return lines.join(\"\\n\") + \"\\n\";\n\n  function encodeBody(header, obj) {\n    lines.push(header);\n    Object.keys(obj).forEach(function (name) {\n      lines.push( \"\\t\" + name + \" = \" + obj[name]);\n    });\n  }\n\n}\n\n\nfunction decode(text) {\n  var config = {};\n  var section;\n  text.split(/[\\r\\n]+/).forEach(function (line) {\n    var match = line.match(/\\[([^ \\t\"\\]]+) *(?:\"([^\"]+)\")?\\]/);\n    if (match) {\n      section = config[match[1]] || (config[match[1]] = {});\n      if (match[2]) {\n        section = section[match[2]] = {};\n      }\n      return;\n    }\n    match = line.match(/([^ \\t=]+)[ \\t]*=[ \\t]*(.+)/);\n    if (match) {\n      section[match[1]] = match[2];\n    }\n  });\n  return config;\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/defer.js":"\"use strict\";\n\nvar timeouts, messageName;\n\n// node.js\nif (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n  module.exports = process.nextTick;\n}\n// some browsers\nelse if (typeof setImmediate === \"function\") {\n  module.exports = setImmediate;\n}\n// most other browsers\nelse {\n  timeouts = [];\n  messageName = \"zero-timeout-message\";\n  window.addEventListener(\"message\", handleMessage, true);\n\n  module.exports = function (fn) {\n    timeouts.push(fn);\n    window.postMessage(messageName, \"*\");\n  };\n}\n\nfunction handleMessage(event) {\n  if (event.source == window && event.data == messageName) {\n    event.stopPropagation();\n    if (timeouts.length > 0) {\n      var fn = timeouts.shift();\n      fn();\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/deflate.js":"var pako = require('pako');\nvar Binary = require('bodec').Binary;\nif (Binary === Uint8Array) {\n  module.exports = pako.deflate;\n}\nelse {\n  module.exports = function deflate(value) {\n    return new Binary(pako.deflate(new Uint8Array(value)));\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/find-common.js":"function oneCall(fn) {\n  var done = false;\n  return function () {\n    if (done) return;\n    done = true;\n    return fn.apply(this, arguments);\n  };\n}\n\nmodule.exports = findCommon;\n\nfunction findCommon(repo, a, b, callback) {\n  callback = oneCall(callback);\n  var ahead = 0, behind = 0;\n  var aStream, bStream;\n  var aCommit, bCommit;\n\n  if (a === b) return callback(null, ahead, behind);\n  repo.logWalk(a, onAStream);\n  repo.logWalk(b, onBStream);\n\n  function onAStream(err, stream) {\n    if (err) return callback(err);\n    aStream = stream;\n    aStream.read(onA);\n  }\n\n  function onBStream(err, stream) {\n    if (err) return callback(err);\n    bStream = stream;\n    bStream.read(onB);\n  }\n\n  function onA(err, commit) {\n    if (!commit) return callback(err || new Error(\"No common commit\"));\n    aCommit = commit;\n    if (bCommit) compare();\n  }\n\n  function onB(err, commit) {\n    if (!commit) return callback(err || new Error(\"No common commit\"));\n    bCommit = commit;\n    if (aCommit) compare();\n  }\n\n  function compare() {\n    if (aCommit.hash === bCommit.hash) return callback(null, ahead, behind);\n    if (aCommit.author.date.seconds > bCommit.author.date.seconds) {\n      ahead++;\n      aStream.read(onA);\n    }\n    else {\n      behind++;\n      bStream.read(onB);\n    }\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/inflate.js":"var pako = require('pako');\nvar Binary = require('bodec').Binary;\nif (Binary === Uint8Array) {\n  module.exports = pako.inflate;\n}\nelse {\n  module.exports = function inflate(value) {\n    return new Binary(pako.inflate(new Uint8Array(value)));\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/inflate-stream.js":"var Inflate = require('pako').Inflate;\nvar Binary = require('bodec').Binary;\n\n// Byte oriented inflate stream.  Wrapper for pako's Inflate.\n//\n//   var inf = inflate();\n//   inf.write(byte) -> more - Write a byte to inflate's state-machine.\n//                             Returns true if more data is expected.\n//   inf.recycle()           - Reset the internal state machine.\n//   inf.flush() -> data     - Flush the output as a binary buffer.\n//\nmodule.exports = function inflateStream() {\n  var inf = new Inflate();\n  var b = new Uint8Array(1);\n  var empty = new Binary(0);\n\n  return {\n    write: write,\n    recycle: recycle,\n    flush: Binary === Uint8Array ? flush : flushConvert\n  };\n\n  function write(byte) {\n    b[0] = byte;\n    inf.push(b);\n    return !inf.ended;\n  }\n\n  function recycle() { inf = new Inflate(); }\n\n  function flush() { return inf.result || empty; }\n\n  function flushConvert() {\n    return inf.result ? new Binary(inf.result) : empty;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/modes.js":"\"use strict\";\n\nvar masks = {\n  mask:   parseInt('100000', 8),\n  blob:   parseInt('140000', 8),\n  file:   parseInt('160000', 8)\n};\n\nvar modes = module.exports = {\n  isBlob: function (mode) {\n    return (mode & masks.blob) === masks.mask;\n  },\n  isFile: function (mode) {\n    return (mode & masks.file) === masks.mask;\n  },\n  toType: function (mode) {\n    if (mode === modes.commit) return \"commit\";\n    if (mode === modes.tree) return \"tree\";\n    if ((mode & masks.blob) === masks.mask) return \"blob\";\n    return \"unknown\";\n  },\n  tree:   parseInt( '40000', 8),\n  blob:   parseInt('100644', 8),\n  file:   parseInt('100644', 8),\n  exec:   parseInt('100755', 8),\n  sym:    parseInt('120000', 8),\n  commit: parseInt('160000', 8)\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/object-codec.js":"\"use strict\";\nvar bodec = require('bodec');\nvar modes = require('./modes');\n\n// (body) -> raw-buffer\nvar encoders = exports.encoders = {\n  blob: encodeBlob,\n  tree: encodeTree,\n  commit: encodeCommit,\n  tag: encodeTag\n};\n\n  // ({type:type, body:raw-buffer}) -> buffer\nexports.frame = frame;\n\n// (raw-buffer) -> body\nvar decoders = exports.decoders ={\n  blob: decodeBlob,\n  tree: decodeTree,\n  commit: decodeCommit,\n  tag: decodeTag\n};\n\n// (buffer) -> {type:type, body:raw-buffer}\nexports.deframe = deframe;\n\n// Export git style path sort in case it's wanted.\nexports.treeMap = treeMap;\nexports.treeSort = treeSort;\n\nfunction encodeBlob(body) {\n  if (!bodec.isBinary(body)) throw new TypeError(\"Blobs must be binary values\");\n  return body;\n}\n\nfunction treeMap(key) {\n  /*jshint validthis:true*/\n  var entry = this[key];\n  return {\n    name: key,\n    mode: entry.mode,\n    hash: entry.hash\n  };\n}\n\nfunction treeSort(a, b) {\n  var aa = (a.mode === modes.tree) ? a.name + \"/\" : a.name;\n  var bb = (b.mode === modes.tree) ? b.name + \"/\" : b.name;\n  return aa > bb ? 1 : aa < bb ? -1 : 0;\n}\n\nfunction encodeTree(body) {\n  var tree = \"\";\n  if (Array.isArray(body)) throw new TypeError(\"Tree must be in object form\");\n  var list = Object.keys(body).map(treeMap, body).sort(treeSort);\n  for (var i = 0, l = list.length; i < l; i++) {\n    var entry = list[i];\n    tree += entry.mode.toString(8) + \" \" + bodec.encodeUtf8(entry.name) +\n            \"\\0\" + bodec.decodeHex(entry.hash);\n  }\n  return bodec.fromRaw(tree);\n}\n\nfunction encodeTag(body) {\n  var str = \"object \" + body.object +\n    \"\\ntype \" + body.type +\n    \"\\ntag \" + body.tag +\n    \"\\ntagger \" + formatPerson(body.tagger) +\n    \"\\n\\n\" + body.message;\n  return bodec.fromUnicode(str);\n}\n\nfunction encodeCommit(body) {\n  var str = \"tree \" + body.tree;\n  for (var i = 0, l = body.parents.length; i < l; ++i) {\n    str += \"\\nparent \" + body.parents[i];\n  }\n  str += \"\\nauthor \" + formatPerson(body.author) +\n         \"\\ncommitter \" + formatPerson(body.committer) +\n         \"\\n\\n\" + body.message;\n  return bodec.fromUnicode(str);\n}\n\n\nfunction formatPerson(person) {\n  return safe(person.name) +\n    \" <\" + safe(person.email) + \"> \" +\n    formatDate(person.date);\n}\n\nfunction safe(string) {\n  return string.replace(/(?:^[\\.,:;<>\"']+|[\\0\\n<>]+|[\\.,:;<>\"']+$)/gm, \"\");\n}\n\nfunction two(num) {\n  return (num < 10 ? \"0\" : \"\") + num;\n}\n\nfunction formatDate(date) {\n  var seconds, offset;\n  if (date.seconds) {\n    seconds = date.seconds;\n    offset = date.offset;\n  }\n  // Also accept Date instances\n  else {\n    seconds = Math.floor(date.getTime() / 1000);\n    offset = date.getTimezoneOffset();\n  }\n  var neg = \"+\";\n  if (offset <= 0) offset = -offset;\n  else neg = \"-\";\n  offset = neg + two(Math.floor(offset / 60)) + two(offset % 60);\n  return seconds + \" \" + offset;\n}\n\nfunction frame(obj) {\n  var type = obj.type;\n  var body = obj.body;\n  if (!bodec.isBinary(body)) body = encoders[type](body);\n  return bodec.join([\n    bodec.fromRaw(type + \" \" + body.length + \"\\0\"),\n    body\n  ]);\n}\n\nfunction decodeBlob(body) {\n  return body;\n}\n\nfunction decodeTree(body) {\n  var i = 0;\n  var length = body.length;\n  var start;\n  var mode;\n  var name;\n  var hash;\n  var tree = {};\n  while (i < length) {\n    start = i;\n    i = indexOf(body, 0x20, start);\n    if (i < 0) throw new SyntaxError(\"Missing space\");\n    mode = parseOct(body, start, i++);\n    start = i;\n    i = indexOf(body, 0x00, start);\n    name = bodec.toUnicode(body, start, i++);\n    hash = bodec.toHex(body, i, i += 20);\n    tree[name] = {\n      mode: mode,\n      hash: hash\n    };\n  }\n  return tree;\n}\n\nfunction decodeCommit(body) {\n  var i = 0;\n  var start;\n  var key;\n  var parents = [];\n  var commit = {\n    tree: \"\",\n    parents: parents,\n    author: \"\",\n    committer: \"\",\n    message: \"\"\n  };\n  while (body[i] !== 0x0a) {\n    start = i;\n    i = indexOf(body, 0x20, start);\n    if (i < 0) throw new SyntaxError(\"Missing space\");\n    key = bodec.toRaw(body, start, i++);\n    start = i;\n    i = indexOf(body, 0x0a, start);\n    if (i < 0) throw new SyntaxError(\"Missing linefeed\");\n    var value = bodec.toUnicode(body, start, i++);\n    if (key === \"parent\") {\n      parents.push(value);\n    }\n    else {\n      if (key === \"author\" || key === \"committer\") {\n        value = decodePerson(value);\n      }\n      commit[key] = value;\n    }\n  }\n  i++;\n  commit.message = bodec.toUnicode(body, i, body.length);\n  return commit;\n}\n\nfunction decodeTag(body) {\n  var i = 0;\n  var start;\n  var key;\n  var tag = {};\n  while (body[i] !== 0x0a) {\n    start = i;\n    i = indexOf(body, 0x20, start);\n    if (i < 0) throw new SyntaxError(\"Missing space\");\n    key = bodec.toRaw(body, start, i++);\n    start = i;\n    i = indexOf(body, 0x0a, start);\n    if (i < 0) throw new SyntaxError(\"Missing linefeed\");\n    var value = bodec.toUnicode(body, start, i++);\n    if (key === \"tagger\") value = decodePerson(value);\n    tag[key] = value;\n  }\n  i++;\n  tag.message = bodec.toUnicode(body, i, body.length);\n  return tag;\n}\n\nfunction decodePerson(string) {\n  var match = string.match(/^([^<]*) <([^>]*)> ([^ ]*) (.*)$/);\n  if (!match) throw new Error(\"Improperly formatted person string\");\n  return {\n    name: match[1],\n    email: match[2],\n    date: {\n      seconds: parseInt(match[3], 10),\n      offset: parseInt(match[4], 10) / 100 * -60\n    }\n  };\n}\n\nfunction deframe(buffer, decode) {\n  var space = indexOf(buffer, 0x20);\n  if (space < 0) throw new Error(\"Invalid git object buffer\");\n  var nil = indexOf(buffer, 0x00, space);\n  if (nil < 0) throw new Error(\"Invalid git object buffer\");\n  var body = bodec.slice(buffer, nil + 1);\n  var size = parseDec(buffer, space + 1, nil);\n  if (size !== body.length) throw new Error(\"Invalid body length.\");\n  var type = bodec.toRaw(buffer, 0, space);\n  return {\n    type: type,\n    body: decode ? decoders[type](body) : body\n  };\n}\n\nfunction indexOf(buffer, byte, i) {\n  i |= 0;\n  var length = buffer.length;\n  for (;;i++) {\n    if (i >= length) return -1;\n    if (buffer[i] === byte) return i;\n  }\n}\n\nfunction parseOct(buffer, start, end) {\n  var val = 0;\n  while (start < end) {\n    val = (val << 3) + buffer[start++] - 0x30;\n  }\n  return val;\n}\n\nfunction parseDec(buffer, start, end) {\n  var val = 0;\n  while (start < end) {\n    val = val * 10 + buffer[start++] - 0x30;\n  }\n  return val;\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/pack-codec.js":"var inflateStream = require('./inflate-stream.js');\nvar inflate = require('./inflate.js');\nvar deflate = require('./deflate.js');\nvar sha1 = require('git-sha1');\nvar bodec = require('bodec');\n\nvar typeToNum = {\n  commit: 1,\n  tree: 2,\n  blob: 3,\n  tag: 4,\n  \"ofs-delta\": 6,\n  \"ref-delta\": 7\n};\nvar numToType = {};\nfor (var type in typeToNum) {\n  var num = typeToNum[type];\n  numToType[num] = type;\n}\nexports.parseEntry = parseEntry;\nfunction parseEntry(chunk) {\n  var offset = 0;\n  var byte = chunk[offset++];\n  var type = numToType[(byte >> 4) & 0x7];\n  var size = byte & 0xf;\n  var left = 4;\n  while (byte & 0x80) {\n    byte = chunk[offset++];\n    size |= (byte & 0x7f) << left;\n    left += 7;\n  }\n  size = size >>> 0;\n  var ref;\n  if (type === \"ref-delta\") {\n    ref = bodec.toHex(bodec.slice(chunk, offset, offset += 20));\n  }\n  else if (type === \"ofs-delta\") {\n    byte = chunk[offset++];\n    ref = byte & 0x7f;\n    while (byte & 0x80) {\n      byte = chunk[offset++];\n      ref = ((ref + 1) << 7) | (byte & 0x7f);\n    }\n  }\n\n  var body = inflate(bodec.slice(chunk, offset));\n  if (body.length !== size) {\n    throw new Error(\"Size mismatch\");\n  }\n  var result = {\n    type: type,\n    body: body\n  };\n  if (typeof ref !== \"undefined\") {\n    result.ref = ref;\n  }\n  return result;\n}\n\n\nexports.decodePack = decodePack;\nfunction decodePack(emit) {\n\n  var state = $pack;\n  var sha1sum = sha1();\n  var inf = inflateStream();\n\n  var offset = 0;\n  var position = 0;\n  var version = 0x4b434150; // PACK reversed\n  var num = 0;\n  var type = 0;\n  var length = 0;\n  var ref = null;\n  var checksum = \"\";\n  var start = 0;\n  var parts = [];\n\n\n  return function (chunk) {\n    if (chunk === undefined) {\n      if (num || checksum.length < 40) throw new Error(\"Unexpected end of input stream\");\n      return emit();\n    }\n\n    for (var i = 0, l = chunk.length; i < l; i++) {\n      // console.log([state, i, chunk[i].toString(16)]);\n      if (!state) throw new Error(\"Unexpected extra bytes: \" + bodec.slice(chunk, i));\n      state = state(chunk[i], i, chunk);\n      position++;\n    }\n    if (!state) return;\n    if (state !== $checksum) sha1sum.update(chunk);\n    var buff = inf.flush();\n    if (buff.length) {\n      parts.push(buff);\n    }\n  };\n\n  // The first four bytes in a packfile are the bytes 'PACK'\n  function $pack(byte) {\n    if ((version & 0xff) === byte) {\n      version >>>= 8;\n      return version ? $pack : $version;\n    }\n    throw new Error(\"Invalid packfile header\");\n  }\n\n  // The version is stored as an unsigned 32 integer in network byte order.\n  // It must be version 2 or 3.\n  function $version(byte) {\n    version = (version << 8) | byte;\n    if (++offset < 4) return $version;\n    if (version >= 2 && version <= 3) {\n      offset = 0;\n      return $num;\n    }\n    throw new Error(\"Invalid version number \" + num);\n  }\n\n  // The number of objects in this packfile is also stored as an unsigned 32 bit int.\n  function $num(byte) {\n    num = (num << 8) | byte;\n    if (++offset < 4) return $num;\n    offset = 0;\n    emit({version: version, num: num});\n    return $header;\n  }\n\n  // n-byte type and length (3-bit type, (n-1)*7+4-bit length)\n  // CTTTSSSS\n  // C is continue bit, TTT is type, S+ is length\n  function $header(byte) {\n    if (start === 0) start = position;\n    type = byte >> 4 & 0x07;\n    length = byte & 0x0f;\n    if (byte & 0x80) {\n      offset = 4;\n      return $header2;\n    }\n    return afterHeader();\n  }\n\n  // Second state in the same header parsing.\n  // CSSSSSSS*\n  function $header2(byte) {\n    length |= (byte & 0x7f) << offset;\n    if (byte & 0x80) {\n      offset += 7;\n      return $header2;\n    }\n    return afterHeader();\n  }\n\n  // Common helper for finishing tiny and normal headers.\n  function afterHeader() {\n    offset = 0;\n    if (type === 6) {\n      ref = 0;\n      return $ofsDelta;\n    }\n    if (type === 7) {\n      ref = \"\";\n      return $refDelta;\n    }\n    // console.log({type: type,length: length})\n    return $body;\n  }\n\n  // Big-endian modified base 128 number encoded ref offset\n  function $ofsDelta(byte) {\n    ref = byte & 0x7f;\n    if (byte & 0x80) return $ofsDelta2;\n    return $body;\n  }\n\n  function $ofsDelta2(byte) {\n    ref = ((ref + 1) << 7) | (byte & 0x7f);\n    if (byte & 0x80) return $ofsDelta2;\n    return $body;\n  }\n\n  // 20 byte raw sha1 hash for ref\n  function $refDelta(byte) {\n    ref += toHex(byte);\n    if (++offset < 20) return $refDelta;\n    return $body;\n  }\n\n  // Common helper for generating 2-character hex numbers\n  function toHex(num) {\n    return num < 0x10 ? \"0\" + num.toString(16) : num.toString(16);\n  }\n\n  // Common helper for emitting all three object shapes\n  function emitObject() {\n    var body = bodec.join(parts);\n    if (body.length !== length) {\n      throw new Error(\"Body length mismatch\");\n    }\n    var item = {\n      type: numToType[type],\n      size: length,\n      body: body,\n      offset: start\n    };\n    if (ref) item.ref = ref;\n    parts.length = 0;\n    start = 0;\n    offset = 0;\n    type = 0;\n    length = 0;\n    ref = null;\n    emit(item);\n  }\n\n  // Feed the deflated code to the inflate engine\n  function $body(byte, i, chunk) {\n    if (inf.write(byte)) return $body;\n    var buf = inf.flush();\n    if (buf.length !== length) throw new Error(\"Length mismatch, expected \" + length + \" got \" + buf.length);\n    inf.recycle();\n    if (buf.length) {\n      parts.push(buf);\n    }\n    emitObject();\n    // If this was all the objects, start calculating the sha1sum\n    if (--num) return $header;\n    sha1sum.update(bodec.slice(chunk, 0, i + 1));\n    return $checksum;\n  }\n\n  // 20 byte checksum\n  function $checksum(byte) {\n    checksum += toHex(byte);\n    if (++offset < 20) return $checksum;\n    var actual = sha1sum.digest();\n    if (checksum !== actual) throw new Error(\"Checksum mismatch: \" + actual + \" != \" + checksum);\n  }\n\n}\n\n\nexports.encodePack = encodePack;\nfunction encodePack(emit) {\n  var sha1sum = sha1();\n  var left;\n  return function (item) {\n    if (item === undefined) {\n      if (left !== 0) throw new Error(\"Some items were missing\");\n      return emit();\n    }\n    if (typeof item.num === \"number\") {\n      if (left !== undefined) throw new Error(\"Header already sent\");\n      left = item.num;\n      write(packHeader(item.num));\n    }\n    else if (typeof item.type === \"string\" && bodec.isBinary(item.body)) {\n      // The header must be sent before items.\n      if (typeof left !== \"number\") throw new Error(\"Headers not sent yet\");\n\n      // Make sure we haven't sent all the items already\n      if (!left) throw new Error(\"All items already sent\");\n\n      // Send the item in packstream format\n      write(packFrame(item));\n\n      // Send the checksum after the last item\n      if (!--left) {\n        emit(bodec.fromHex(sha1sum.digest()));\n      }\n    }\n    else {\n      throw new Error(\"Invalid item\");\n    }\n  };\n  function write(chunk) {\n    sha1sum.update(chunk);\n    emit(chunk);\n  }\n}\n\nfunction packHeader(length) {\n  return bodec.fromArray([\n    0x50, 0x41, 0x43, 0x4b, // PACK\n    0, 0, 0, 2,             // version 2\n    length >> 24,           // Num of objects\n    (length >> 16) & 0xff,\n    (length >> 8) & 0xff,\n    length & 0xff\n  ]);\n}\n\nfunction packFrame(item) {\n  var length = item.body.length;\n\n  // write TYPE_AND_BASE128_SIZE\n  var head = [(typeToNum[item.type] << 4) | (length & 0xf)];\n  var i = 0;\n  length >>= 4;\n  while (length) {\n    head[i++] |= 0x80;\n    head[i] = length & 0x7f;\n    length >>= 7;\n  }\n\n  if (typeof item.ref === \"number\") {\n    // write BIG_ENDIAN_MODIFIED_BASE_128_NUMBER\n    var offset = item.ref;\n    // Calculate how many digits we need in base 128 and move the pointer\n    i += Math.floor(Math.log(offset) / Math.log(0x80)) + 1;\n    // Write the last digit\n    head[i] = offset & 0x7f;\n    // Then write the rest\n    while (offset >>= 7) {\n      head[--i] = 0x80 | (--offset & 0x7f);\n    }\n  }\n\n  var parts = [bodec.fromArray(head)];\n  if (typeof item.ref === \"string\") {\n    parts.push(bodec.fromHex(item.ref));\n  }\n  parts.push(deflate(item.body));\n  return bodec.join(parts);\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/pkt-line.js":"\"use strict\";\n\nvar bodec = require('bodec');\nvar PACK = bodec.fromRaw(\"PACK\");\n\nmodule.exports = {\n  deframer: deframer,\n  framer: framer\n};\n\nfunction deframer(emit) {\n  var state = 0;\n  var offset = 4;\n  var length = 0;\n  var data;\n  var more = true;\n\n  return function (item) {\n\n    // Forward the EOS marker\n    if (item === undefined) return emit();\n\n    // Once we're in pack mode, everything goes straight through\n    if (state === 3) return emit(item);\n\n    // Otherwise parse the data using a state machine.\n    for (var i = 0, l = item.length; i < l; i++) {\n      var byte = item[i];\n      if (state === 0) {\n        var val = fromHexChar(byte);\n        if (val === -1) {\n          if (byte === PACK[0]) {\n            offset = 1;\n            state = 2;\n            continue;\n          }\n          state = -1;\n          throw new SyntaxError(\"Not a hex char: \" + String.fromCharCode(byte));\n        }\n        length |= val << ((--offset) * 4);\n        if (offset === 0) {\n          if (length === 4) {\n            offset = 4;\n            more = emit(\"\");\n          }\n          else if (length === 0) {\n            offset = 4;\n            more = emit(null);\n          }\n          else if (length > 4) {\n            length -= 4;\n            data = bodec.create(length);\n            state = 1;\n          }\n          else {\n            state = -1;\n            throw new SyntaxError(\"Invalid length: \" + length);\n          }\n        }\n      }\n      else if (state === 1) {\n        data[offset++] = byte;\n        if (offset === length) {\n          offset = 4;\n          state = 0;\n          length = 0;\n          if (data[0] === 1) {\n            more = emit(bodec.slice(data, 1));\n          }\n          else if (data[0] === 2) {\n            more = emit({progress: bodec.toUnicode(data, 1)});\n          }\n          else if (data[0] === 3) {\n            more = emit({error: bodec.toUnicode(data, 1)});\n          }\n          else {\n            more = emit(bodec.toUnicode(data).trim());\n          }\n        }\n      }\n      else if (state === 2) {\n        if (offset < 4 && byte === PACK[offset++]) {\n          continue;\n        }\n        state = 3;\n        more = emit(bodec.join([PACK, bodec.subarray(item, i)]));\n        break;\n      }\n      else {\n        throw new Error(\"pkt-line decoder in invalid state\");\n      }\n    }\n\n    return more;\n  };\n\n}\n\nfunction framer(emit) {\n  return function (item) {\n    if (item === undefined) return emit();\n    if (item === null) {\n      return emit(bodec.fromRaw(\"0000\"));\n    }\n    if (typeof item === \"string\") {\n      item = bodec.fromUnicode(item);\n    }\n    return emit(bodec.join([frameHead(item.length + 4), item]));\n  };\n}\n\nfunction frameHead(length) {\n  var buffer = bodec.create(4);\n  buffer[0] = toHexChar(length >>> 12);\n  buffer[1] = toHexChar((length >>> 8) & 0xf);\n  buffer[2] = toHexChar((length >>> 4) & 0xf);\n  buffer[3] = toHexChar(length & 0xf);\n  return buffer;\n}\n\nfunction fromHexChar(val) {\n  return (val >= 0x30 && val <  0x40) ? val - 0x30 :\n        ((val >  0x60 && val <= 0x66) ? val - 0x57 : -1);\n}\n\nfunction toHexChar(val) {\n  return val < 0x0a ? val + 0x30 : val + 0x57;\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/lib/wrap-handler.js":"\"use strict\";\n\nmodule.exports = wrapHandler;\n\nfunction wrapHandler(fn, onError) {\n  if (onError) {\n    return function (err, value) {\n      if (err) return onError(err);\n      try {\n        return fn(value);\n      }\n      catch (err) {\n        return onError(err);\n      }\n    };\n  }\n  return function (err, value) {\n    if (err) throw err;\n    return fn(value);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/add-cache.js":"\"use strict\";\n\nmodule.exports = addCache;\nfunction addCache(repo, cache) {\n  var loadAs = repo.loadAs;\n  if (loadAs) repo.loadAs = loadAsCached;\n  var saveAs = repo.saveAs;\n  if (saveAs) repo.saveAs = saveAsCached;\n  var createTree = repo.createTree;\n  if (createTree) repo.createTree = createTreeCached;\n\n  function loadAsCached(type, hash, callback) {\n    // Next check in disk cache...\n    cache.loadAs(type, hash, onCacheLoad);\n\n    function onCacheLoad(err, value) {\n      if (err) return callback(err);\n      // ...and return if it's there.\n      if (value !== undefined) {\n        return callback(null, value, hash);\n      }\n\n      // Otherwise load from real data source...\n      loadAs.call(repo, type, hash, onLoad);\n    }\n\n    function onLoad(err, value) {\n      if (value === undefined) return callback(err);\n\n      // Store it on disk too...\n      // Force the hash to prevent mismatches.\n      cache.saveAs(type, value, onSave, hash);\n\n      function onSave(err) {\n        if (err) return callback(err);\n        // Finally return the value to caller.\n        callback(null, value, hash);\n      }\n    }\n  }\n\n  function saveAsCached(type, value, callback) {\n    saveAs.call(repo, type, value, onSave);\n\n    function onSave(err, hash) {\n      if (err) return callback(err);\n      // Store in disk, forcing hash to match.\n      cache.saveAs(type, value, callback, hash);\n    }\n  }\n\n  function createTreeCached(entries, callback) {\n    createTree.call(repo, entries, onTree);\n\n    function onTree(err, hash, tree) {\n      if (err) return callback(err);\n      cache.saveAs(\"tree\", tree, callback, hash);\n    }\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/create-tree.js":"\"use strict\";\n\nvar modes = require('../lib/modes.js');\n\nmodule.exports = function (repo) {\n  repo.createTree = createTree;\n\n  function createTree(entries, callback) {\n    if (!callback) return createTree.bind(null, entries);\n    callback = singleCall(callback);\n    if (!Array.isArray(entries)) {\n      entries = Object.keys(entries).map(function (path) {\n        var entry = entries[path];\n        entry.path = path;\n        return entry;\n      });\n    }\n\n    // Tree paths that we need loaded\n    var toLoad = {};\n    function markTree(path) {\n      while(true) {\n        if (toLoad[path]) return;\n        toLoad[path] = true;\n        trees[path] = {\n          add: [],\n          del: [],\n          tree: {}\n        };\n        if (!path) break;\n        path = path.substring(0, path.lastIndexOf(\"/\"));\n      }\n    }\n\n    // Commands to run organized by tree path\n    var trees = {};\n\n    // Counter for parallel I/O operations\n    var left = 1; // One extra counter to protect again zalgo cache callbacks.\n\n    // First pass, stubs out the trees structure, sorts adds from deletes,\n    // and saves any inline content blobs.\n    entries.forEach(function (entry) {\n      var index = entry.path.lastIndexOf(\"/\");\n      var parentPath = entry.path.substr(0, index);\n      var name = entry.path.substr(index + 1);\n      markTree(parentPath);\n      var tree = trees[parentPath];\n      var adds = tree.add;\n      var dels = tree.del;\n\n      if (!entry.mode) {\n        dels.push(name);\n        return;\n      }\n      var add = {\n        name: name,\n        mode: entry.mode,\n        hash: entry.hash\n      };\n      adds.push(add);\n      if (entry.hash) return;\n      left++;\n      repo.saveAs(\"blob\", entry.content, function (err, hash) {\n        if (err) return callback(err);\n        add.hash = hash;\n        check();\n      });\n    });\n\n    // Preload the base trees\n    if (entries.base) loadTree(\"\", entries.base);\n\n    // Check just in case there was no IO to perform\n    check();\n\n    function loadTree(path, hash) {\n      left++;\n      delete toLoad[path];\n      repo.loadAs(\"tree\", hash, function (err, tree) {\n        if (err) return callback(err);\n        trees[path].tree = tree;\n        Object.keys(tree).forEach(function (name) {\n          var childPath = path ? path + \"/\" + name : name;\n          if (toLoad[childPath]) loadTree(childPath, tree[name].hash);\n        });\n        check();\n      });\n    }\n\n    function check() {\n      if (--left) return;\n      findLeaves().forEach(processLeaf);\n    }\n\n    function processLeaf(path) {\n      var entry = trees[path];\n      delete trees[path];\n      var tree = entry.tree;\n      entry.del.forEach(function (name) {\n        delete tree[name];\n      });\n      entry.add.forEach(function (item) {\n        tree[item.name] = {\n          mode: item.mode,\n          hash: item.hash\n        };\n      });\n      left++;\n      repo.saveAs(\"tree\", tree, function (err, hash, tree) {\n        if (err) return callback(err);\n        if (!path) return callback(null, hash, tree);\n        var index = path.lastIndexOf(\"/\");\n        var parentPath = path.substring(0, index);\n        var name = path.substring(index + 1);\n        trees[parentPath].add.push({\n          name: name,\n          mode: modes.tree,\n          hash: hash\n        });\n        if (--left) return;\n        findLeaves().forEach(processLeaf);\n      });\n    }\n\n    function findLeaves() {\n      var paths = Object.keys(trees);\n      var parents = {};\n      paths.forEach(function (path) {\n        if (!path) return;\n        var parent = path.substring(0, path.lastIndexOf(\"/\"));\n        parents[parent] = true;\n      });\n      return paths.filter(function (path) {\n        return !parents[path];\n      });\n    }\n  }\n};\n\nfunction singleCall(callback) {\n  var done = false;\n  return function () {\n    if (done) return console.warn(\"Discarding extra callback\");\n    done = true;\n    return callback.apply(this, arguments);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/delay.js":"\"use strict\";\n\nmodule.exports = function (repo, ms) {\n  var saveAs = repo.saveAs;\n  var loadAs = repo.loadAs;\n  var readRef = repo.readRef;\n  var updateRef = repo.updateRef;\n  var createTree = repo.createTree;\n\n  repo.saveAs = saveAsDelayed;\n  repo.loadAs = loadAsDelayed;\n  repo.readRef = readRefDelayed;\n  repo.updateRed = updateRefDelayed;\n  if (createTree) repo.createTree = createTreeDelayed;\n\n  function saveAsDelayed(type, value, callback) {\n    if (!callback) return saveAsDelayed.bind(repo, type, value);\n    setTimeout(function () {\n      return saveAs.call(repo, type, value, callback);\n    }, ms);\n  }\n\n  function loadAsDelayed(type, hash, callback) {\n    if (!callback) return loadAsDelayed.bind(repo, type, hash);\n    setTimeout(function () {\n      return loadAs.call(repo, type, hash, callback);\n    }, ms);\n  }\n\n  function readRefDelayed(ref, callback) {\n    if (!callback) return readRefDelayed.bind(repo, ref);\n    setTimeout(function () {\n      return readRef.call(repo, ref, callback);\n    }, ms);\n  }\n\n  function updateRefDelayed(ref, hash, callback) {\n    if (!callback) return updateRefDelayed.bind(repo, ref, hash);\n    setTimeout(function () {\n      return updateRef.call(repo, ref, hash, callback);\n    }, ms);\n  }\n\n  function createTreeDelayed(entries, callback) {\n    if (!callback) return createTreeDelayed.bind(repo, entries);\n    setTimeout(function () {\n      return createTree.call(repo, entries, callback);\n    }, ms);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/fall-through.js":"var modes = require('../lib/modes');\n\nmodule.exports = function (local, remote) {\n  var loadAs = local.loadAs;\n  local.loadAs = newLoadAs;\n  function newLoadAs(type, hash, callback) {\n    if (!callback) return newLoadAs.bind(local. type, hash);\n    loadAs.call(local, type, hash, function (err, body) {\n      if (err) return callback(err);\n      if (body === undefined) return remote.loadAs(type, hash, callback);\n      callback(null, body);\n    });\n  }\n\n  var readRef = local.readRef;\n  local.readRef = newReadRef;\n  function newReadRef(ref, callback) {\n    if (!callback) return newReadRef.bind(local. ref);\n    readRef.call(local, ref, function (err, body) {\n      if (err) return callback(err);\n      if (body === undefined) return remote.readRef(ref, callback);\n      callback(null, body);\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/formats.js":"\"use strict\";\n\nvar bodec = require('bodec');\nvar treeMap = require('../lib/object-codec').treeMap;\n\nmodule.exports = function (repo) {\n  var loadAs = repo.loadAs;\n  repo.loadAs = newLoadAs;\n  var saveAs = repo.saveAs;\n  repo.saveAs = newSaveAs;\n\n  function newLoadAs(type, hash, callback) {\n    if (!callback) return newLoadAs.bind(repo, type, hash);\n    var realType = type === \"text\" ? \"blob\":\n                   type === \"array\" ? \"tree\" : type;\n    return loadAs.call(repo, realType, hash, onLoad);\n\n    function onLoad(err, body, hash) {\n      if (body === undefined) return callback(err);\n      if (type === \"text\") body = bodec.toUnicode(body);\n      if (type === \"array\") body = toArray(body);\n      return callback(err, body, hash);\n    }\n  }\n\n  function newSaveAs(type, body, callback) {\n    if (!callback) return newSaveAs.bind(repo, type, body);\n    type = type === \"text\" ? \"blob\":\n           type === \"array\" ? \"tree\" : type;\n    if (type === \"blob\") {\n      if (typeof body === \"string\") {\n        body = bodec.fromUnicode(body);\n      }\n    }\n    else if (type === \"tree\") {\n      body = normalizeTree(body);\n    }\n    else if (type === \"commit\") {\n      body = normalizeCommit(body);\n    }\n    else if (type === \"tag\") {\n      body = normalizeTag(body);\n    }\n    return saveAs.call(repo, type, body, callback);\n  }\n\n};\n\nfunction toArray(tree) {\n  return Object.keys(tree).map(treeMap, tree);\n}\n\nfunction normalizeTree(body) {\n  var type = body && typeof body;\n  if (type !== \"object\") {\n    throw new TypeError(\"Tree body must be array or object\");\n  }\n  var tree = {}, i, l, entry;\n  // If array form is passed in, convert to object form.\n  if (Array.isArray(body)) {\n    for (i = 0, l = body.length; i < l; i++) {\n      entry = body[i];\n      tree[entry.name] = {\n        mode: entry.mode,\n        hash: entry.hash\n      };\n    }\n  }\n  else {\n    var names = Object.keys(body);\n    for (i = 0, l = names.length; i < l; i++) {\n      var name = names[i];\n      entry = body[name];\n      tree[name] = {\n        mode: entry.mode,\n        hash: entry.hash\n      };\n    }\n  }\n  return tree;\n}\n\nfunction normalizeCommit(body) {\n  if (!body || typeof body !== \"object\") {\n    throw new TypeError(\"Commit body must be an object\");\n  }\n  if (!(body.tree && body.author && body.message)) {\n    throw new TypeError(\"Tree, author, and message are required for commits\");\n  }\n  var parents = body.parents || (body.parent ? [ body.parent ] : []);\n  if (!Array.isArray(parents)) {\n    throw new TypeError(\"Parents must be an array\");\n  }\n  var author = normalizePerson(body.author);\n  var committer = body.committer ? normalizePerson(body.committer) : author;\n  return {\n    tree: body.tree,\n    parents: parents,\n    author: author,\n    committer: committer,\n    message: body.message\n  };\n}\n\nfunction normalizeTag(body) {\n  if (!body || typeof body !== \"object\") {\n    throw new TypeError(\"Tag body must be an object\");\n  }\n  if (!(body.object && body.type && body.tag && body.tagger && body.message)) {\n    throw new TypeError(\"Object, type, tag, tagger, and message required\");\n  }\n  return {\n    object: body.object,\n    type: body.type,\n    tag: body.tag,\n    tagger: normalizePerson(body.tagger),\n    message: body.message\n  };\n}\n\nfunction normalizePerson(person) {\n  if (!person || typeof person !== \"object\") {\n    throw new TypeError(\"Person must be an object\");\n  }\n  if (typeof person.name !== \"string\" || typeof person.email !== \"string\") {\n    throw new TypeError(\"Name and email are required for person fields\");\n  }\n  return {\n    name: person.name,\n    email: person.email,\n    date: person.date || new Date()\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/fs-db.js":"\"use strict\";\nvar bodec = require('bodec');\nvar inflate = require('../lib/inflate');\nvar deflate = require('../lib/deflate');\nvar codec = require('../lib/object-codec');\nvar parsePackEntry = require('../lib/pack-codec').parseEntry;\nvar applyDelta = require('../lib/apply-delta');\nvar sha1 = require('git-sha1');\nvar pathJoin = require('path').join;\n\n// The fs object has the following interface:\n// - readFile(path) => binary\n//   Must also call callback() with no arguments if the file does not exist.\n// - readChunk(path, start, end) => binary\n//   Must also call callback() with no arguments if the file does not exist.\n// - writeFile(path, binary) =>\n//   Must also make every directory up to parent of path.\n// - readDir(path) => array<paths>\n//   Must also call callback() with no arguments if the file does not exist.\n// The repo is expected to have a rootPath property that points to\n// the .git folder within the filesystem.\nmodule.exports = function (repo, fs) {\n\n  var cachedIndexes = {};\n\n  repo.loadAs = loadAs;\n  repo.saveAs = saveAs;\n  repo.loadRaw = loadRaw;\n  repo.saveRaw = saveRaw;\n  repo.readRef = readRef;\n  repo.updateRef = updateRef;\n  repo.hasHash = hasHash;\n  repo.init = init;\n  repo.setShallow = setShallow;\n\n  function init(ref, callback) {\n    if (!callback) return init.bind(null, ref);\n    ref = ref || \"refs/heads/master\";\n    var path = pathJoin(repo.rootPath, \"HEAD\");\n    fs.writeFile(path, \"ref: \" + ref, callback);\n  }\n\n  function setShallow(ref, callback) {\n    if (!callback) return setShallow.bind(null, ref);\n    var path = pathJoin(repo.rootPath, \"shallow\");\n    fs.writeFile(path, ref, callback);\n  }\n\n  function updateRef(ref, hash, callback) {\n    if (!callback) return updateRef.bind(repo, ref, hash);\n    var path = pathJoin(repo.rootPath, ref);\n    var lock = path + \".lock\";\n    fs.writeFile(lock, bodec.fromRaw(hash + \"\\n\"), function(err) {\n      if(err) return callback(err);\n      fs.rename(lock, path, callback);\n    });\n  }\n\n  function readRef(ref, callback) {\n    if (!callback) return readRef.bind(repo, ref);\n    var path = pathJoin(repo.rootPath, ref);\n    fs.readFile(path, function (err, binary) {\n      if (err) return callback(err);\n      if (binary === undefined) {\n        return readPackedRef(ref, callback);\n      }\n      var hash;\n      try { hash = bodec.toRaw(binary).trim(); }\n      catch (err) { return callback(err); }\n      callback(null, hash);\n    });\n  }\n\n  function readPackedRef(ref, callback) {\n    var path = pathJoin(repo.rootPath, \"packed-refs\");\n    fs.readFile(path, function (err, binary) {\n      if (binary === undefined) return callback(err);\n      var hash;\n      try {\n        var text = bodec.toRaw(binary);\n        var index = text.indexOf(ref);\n        if (index >= 0) {\n          hash = text.substring(index - 41, index - 1);\n        }\n      }\n      catch (err) {\n        return callback(err);\n      }\n      callback(null, hash);\n    });\n  }\n\n  function saveAs(type, body, callback) {\n    if (!callback) return saveAs.bind(repo, type, body);\n    var raw, hash;\n    try {\n      raw = codec.frame({\n        type: type,\n        body: codec.encoders[type](body)\n      });\n      hash = sha1(raw);\n    }\n    catch (err) { return callback(err); }\n    saveRaw(hash, raw, function (err) {\n      if (err) return callback(err);\n      callback(null, hash);\n    });\n  }\n\n  function saveRaw(hash, raw, callback) {\n    if (!callback) return saveRaw.bind(repo, hash, raw);\n    var buffer, path;\n    try {\n      if (sha1(raw) !== hash) {\n        throw new Error(\"Save data does not match hash\");\n      }\n      buffer = deflate(raw);\n      path = hashToPath(hash);\n    }\n    catch (err) { return callback(err); }\n    // Try to read the object first.\n    loadRaw(hash, function (err, data) {\n      // If it already exists, we're done\n      if (data) return callback();\n      // Otherwise write a new file\n      var tmp = path.replace(/[0-9a-f]+$/, 'tmp_obj_' + Math.random().toString(36).substr(2))\n      fs.writeFile(tmp, buffer, function(err) {\n        if(err) return callback(err);\n        fs.rename(tmp, path, callback);\n      });\n    });\n  }\n\n  function loadAs(type, hash, callback) {\n    if (!callback) return loadAs.bind(repo, type, hash);\n    loadRaw(hash, function (err, raw) {\n      if (raw === undefined) return callback(err);\n      var body;\n      try {\n        raw = codec.deframe(raw);\n        if (raw.type !== type) throw new TypeError(\"Type mismatch\");\n        body = codec.decoders[raw.type](raw.body);\n      }\n      catch (err) { return callback(err); }\n      callback(null, body);\n    });\n  }\n\n  function hasHash(hash, callback) {\n    if (!callback) return hasHash.bind(repo, hash);\n    loadRaw(hash, function (err, body) {\n      if (err) return callback(err);\n      return callback(null, !!body);\n    });\n  }\n\n  function loadRaw(hash, callback) {\n    if (!callback) return loadRaw.bind(repo, hash);\n    var path = hashToPath(hash);\n    fs.readFile(path, function (err, buffer) {\n      if (err) return callback(err);\n      if (buffer) {\n        var raw;\n        try { raw = inflate(buffer); }\n        catch (err) { return callback(err); }\n        return callback(null, raw);\n      }\n      return loadRawPacked(hash, callback);\n    });\n  }\n\n  function loadRawPacked(hash, callback) {\n    var packDir = pathJoin(repo.rootPath, \"objects/pack\");\n    var packHashes = [];\n    fs.readDir(packDir, function (err, entries) {\n      if (!entries) return callback(err);\n      entries.forEach(function (name) {\n        var match = name.match(/pack-([0-9a-f]{40}).idx/);\n        if (match) packHashes.push(match[1]);\n      });\n      start();\n    });\n\n    function start() {\n      var packHash = packHashes.pop();\n      var offsets;\n      if (!packHash) return callback();\n      if (!cachedIndexes[packHash]) loadIndex(packHash);\n      else onIndex();\n\n      function loadIndex() {\n        var indexFile = pathJoin(packDir, \"pack-\" + packHash + \".idx\" );\n        fs.readFile(indexFile, function (err, buffer) {\n          if (!buffer) return callback(err);\n          try {\n            cachedIndexes[packHash] = parseIndex(buffer);\n          }\n          catch (err) { return callback(err); }\n          onIndex();\n        });\n      }\n\n      function onIndex() {\n        var cached = cachedIndexes[packHash];\n        var packFile = pathJoin(packDir, \"pack-\" + packHash + \".pack\" );\n        var index = cached.byHash[hash];\n        if (!index) return start();\n        offsets = cached.offsets;\n        loadChunk(packFile, index.offset, callback);\n      }\n\n      function loadChunk(packFile, start, callback) {\n        var index = offsets.indexOf(start);\n        if (index < 0) {\n          var error = new Error(\"Can't find chunk starting at \" + start);\n          return callback(error);\n        }\n        var end = index + 1 < offsets.length ? offsets[index + 1] : -20;\n        fs.readChunk(packFile, start, end, function (err, chunk) {\n          if (!chunk) return callback(err);\n          var raw;\n          try {\n            var entry = parsePackEntry(chunk);\n            if (entry.type === \"ref-delta\") {\n              return loadRaw.call(repo, entry.ref, onBase);\n            }\n            else if (entry.type === \"ofs-delta\") {\n              return loadChunk(packFile, start - entry.ref, onBase);\n            }\n            raw = codec.frame(entry);\n          }\n          catch (err) { return callback(err); }\n          callback(null, raw);\n\n          function onBase(err, base) {\n            if (!base) return callback(err);\n            var object = codec.deframe(base);\n            var buffer;\n            try {\n              object.body = applyDelta(entry.body, object.body);\n              buffer = codec.frame(object);\n            }\n            catch (err) { return callback(err); }\n            callback(null, buffer);\n          }\n        });\n      }\n\n    }\n  }\n\n  function hashToPath(hash) {\n    return pathJoin(repo.rootPath, \"objects\", hash.substring(0, 2), hash.substring(2));\n  }\n\n};\n\nfunction parseIndex(buffer) {\n  if (readUint32(buffer, 0) !== 0xff744f63 ||\n      readUint32(buffer, 4) !== 0x00000002) {\n    throw new Error(\"Only v2 pack indexes supported\");\n  }\n\n  // Get the number of hashes in index\n  // This is the value of the last fan-out entry\n  var hashOffset = 8 + 255 * 4;\n  var length = readUint32(buffer, hashOffset);\n  hashOffset += 4;\n  var crcOffset = hashOffset + 20 * length;\n  var lengthOffset = crcOffset + 4 * length;\n  var largeOffset = lengthOffset + 4 * length;\n  var checkOffset = largeOffset;\n  var indexes = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var start = hashOffset + i * 20;\n    var hash = bodec.toHex(bodec.slice(buffer, start, start + 20));\n    var crc = readUint32(buffer, crcOffset + i * 4);\n    var offset = readUint32(buffer, lengthOffset + i * 4);\n    if (offset & 0x80000000) {\n      offset = largeOffset + (offset &0x7fffffff) * 8;\n      checkOffset = Math.max(checkOffset, offset + 8);\n      offset = readUint64(buffer, offset);\n    }\n    indexes[i] = {\n      hash: hash,\n      offset: offset,\n      crc: crc\n    };\n  }\n  var packChecksum = bodec.toHex(bodec.slice(buffer, checkOffset, checkOffset + 20));\n  var checksum = bodec.toHex(bodec.slice(buffer, checkOffset + 20, checkOffset + 40));\n  if (sha1(bodec.slice(buffer, 0, checkOffset + 20)) !== checksum) {\n    throw new Error(\"Checksum mistmatch\");\n  }\n\n  var byHash = {};\n  indexes.sort(function (a, b) {\n    return a.offset - b.offset;\n  });\n  indexes.forEach(function (data) {\n    byHash[data.hash] = {\n      offset: data.offset,\n      crc: data.crc,\n    };\n  });\n  var offsets = indexes.map(function (entry) {\n    return entry.offset;\n  }).sort(function (a, b) {\n    return a - b;\n  });\n\n  return {\n    offsets: offsets,\n    byHash: byHash,\n    checksum: packChecksum\n  };\n}\n\nfunction readUint32(buffer, offset) {\n  return (buffer[offset] << 24 |\n          buffer[offset + 1] << 16 |\n          buffer[offset + 2] << 8 |\n          buffer[offset + 3] << 0) >>> 0;\n}\n\n// Yes this will lose precision over 2^53, but that can't be helped when\n// returning a single integer.\n// We simply won't support packfiles over 8 petabytes. I'm ok with that.\nfunction readUint64(buffer, offset) {\n  var hi = (buffer[offset] << 24 |\n            buffer[offset + 1] << 16 |\n            buffer[offset + 2] << 8 |\n            buffer[offset + 3] << 0) >>> 0;\n  var lo = (buffer[offset + 4] << 24 |\n            buffer[offset + 5] << 16 |\n            buffer[offset + 6] << 8 |\n            buffer[offset + 7] << 0) >>> 0;\n  return hi * 0x100000000 + lo;\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/indexed-db.js":"\"use strict\";\n/*global indexedDB*/\n\nvar codec = require('../lib/object-codec.js');\nvar sha1 = require('git-sha1');\nvar modes = require('../lib/modes.js');\nvar db;\n\nmixin.init = init;\n\nmixin.loadAs = loadAs;\nmixin.saveAs = saveAs;\nmodule.exports = mixin;\n\nfunction init(callback) {\n\n  db = null;\n  var request = indexedDB.open(\"tedit\", 1);\n\n  // We can only create Object stores in a versionchange transaction.\n  request.onupgradeneeded = function(evt) {\n    var db = evt.target.result;\n\n    if (evt.dataLoss && evt.dataLoss !== \"none\") {\n      return callback(new Error(evt.dataLoss + \": \" + evt.dataLossMessage));\n    }\n\n    // A versionchange transaction is started automatically.\n    evt.target.transaction.onerror = onError;\n\n    if(db.objectStoreNames.contains(\"objects\")) {\n      db.deleteObjectStore(\"objects\");\n    }\n    if(db.objectStoreNames.contains(\"refs\")) {\n      db.deleteObjectStore(\"refs\");\n    }\n\n    db.createObjectStore(\"objects\", {keyPath: \"hash\"});\n    db.createObjectStore(\"refs\", {keyPath: \"path\"});\n  };\n\n  request.onsuccess = function (evt) {\n    db = evt.target.result;\n    callback();\n  };\n  request.onerror = onError;\n}\n\n\nfunction mixin(repo, prefix) {\n  if (!prefix) throw new Error(\"Prefix required\");\n  repo.refPrefix = prefix;\n  repo.saveAs = saveAs;\n  repo.loadAs = loadAs;\n  repo.readRef = readRef;\n  repo.updateRef = updateRef;\n  repo.hasHash = hasHash;\n}\n\nfunction onError(evt) {\n  console.error(\"error\", evt.target.error);\n}\n\nfunction saveAs(type, body, callback, forcedHash) {\n  if (!callback) return saveAs.bind(this, type, body);\n  var hash;\n  try {\n    var buffer = codec.frame({type:type,body:body});\n    hash = forcedHash || sha1(buffer);\n  }\n  catch (err) { return callback(err); }\n  var trans = db.transaction([\"objects\"], \"readwrite\");\n  var store = trans.objectStore(\"objects\");\n  var entry = { hash: hash, type: type, body: body };\n  var request = store.put(entry);\n  request.onsuccess = function() {\n    // console.warn(\"SAVE\", type, hash);\n    callback(null, hash, body);\n  };\n  request.onerror = function(evt) {\n    callback(new Error(evt.value));\n  };\n}\n\nfunction loadAs(type, hash, callback) {\n  if (!callback) return loadAs.bind(this, type, hash);\n  loadRaw(hash, function (err, entry) {\n    if (!entry) return callback(err);\n    if (type !== entry.type) {\n      return callback(new TypeError(\"Type mismatch\"));\n    }\n    callback(null, entry.body, hash);\n  });\n}\n\nfunction loadRaw(hash, callback) {\n  var trans = db.transaction([\"objects\"], \"readwrite\");\n  var store = trans.objectStore(\"objects\");\n  var request = store.get(hash);\n  request.onsuccess = function(evt) {\n    var entry = evt.target.result;\n    if (!entry) return callback();\n    return callback(null, entry);\n  };\n  request.onerror = function(evt) {\n    callback(new Error(evt.value));\n  };\n}\n\nfunction hasHash(hash, callback) {\n  if (!callback) return hasHash.bind(this, hash);\n  loadRaw(hash, function (err, body) {\n    if (err) return callback(err);\n    return callback(null, !!body);\n  });\n}\n\nfunction readRef(ref, callback) {\n  if (!callback) return readRef.bind(this, ref);\n  var key = this.refPrefix + \"/\" + ref;\n  var trans = db.transaction([\"refs\"], \"readwrite\");\n  var store = trans.objectStore(\"refs\");\n  var request = store.get(key);\n  request.onsuccess = function(evt) {\n    var entry = evt.target.result;\n    if (!entry) return callback();\n    callback(null, entry.hash);\n  };\n  request.onerror = function(evt) {\n    callback(new Error(evt.value));\n  };\n}\n\nfunction updateRef(ref, hash, callback) {\n  if (!callback) return updateRef.bind(this, ref, hash);\n  var key = this.refPrefix + \"/\" + ref;\n  var trans = db.transaction([\"refs\"], \"readwrite\");\n  var store = trans.objectStore(\"refs\");\n  var entry = { path: key, hash: hash };\n  var request = store.put(entry);\n  request.onsuccess = function() {\n    callback();\n  };\n  request.onerror = function(evt) {\n    callback(new Error(evt.value));\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/mem-cache.js":"\"use strict\";\n\nvar encoders = require('../lib/object-codec').encoders;\nvar decoders = require('../lib/object-codec').decoders;\nvar Binary = require('bodec').Binary;\n\nvar cache = memCache.cache = {};\nmodule.exports = memCache;\n\nfunction memCache(repo) {\n  var loadAs = repo.loadAs;\n  repo.loadAs = loadAsCached;\n  function loadAsCached(type, hash, callback) {\n    if (!callback) return loadAsCached.bind(this, type, hash);\n    if (hash in cache) return callback(null, dupe(type, cache[hash]), hash);\n    loadAs.call(repo, type, hash, function (err, value) {\n      if (value === undefined) return callback(err);\n      if (type !== \"blob\" || value.length < 100) {\n        cache[hash] = dupe(type, value);\n      }\n      return callback.apply(this, arguments);\n    });\n  }\n\n  var saveAs = repo.saveAs;\n  repo.saveAs = saveAsCached;\n  function saveAsCached(type, value, callback) {\n    if (!callback) return saveAsCached.bind(this, type, value);\n    value = dupe(type, value);\n    saveAs.call(repo, type, value, function (err, hash) {\n      if (err) return callback(err);\n      if (type !== \"blob\" || value.length < 100) {\n        cache[hash] = value;\n      }\n      return callback(null, hash, value);\n    });\n  }\n}\nfunction dupe(type, value) {\n  if (type === \"blob\") {\n    if (type.length >= 100) return value;\n    return new Binary(value);\n  }\n  return decoders[type](encoders[type](value));\n}\n\nfunction deepFreeze(obj) {\n  Object.freeze(obj);\n  Object.keys(obj).forEach(function (key) {\n    var value = obj[key];\n    if (typeof value === \"object\") deepFreeze(value);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/mem-db.js":"\"use strict\";\n\nvar defer = require('../lib/defer.js');\nvar codec = require('../lib/object-codec.js');\nvar sha1 = require('git-sha1');\n\nmodule.exports = mixin;\nvar isHash = /^[0-9a-f]{40}$/;\n\nfunction mixin(repo) {\n  var objects = {};\n  var refs = {};\n\n  repo.saveAs = saveAs;\n  repo.loadAs = loadAs;\n  repo.saveRaw = saveRaw;\n  repo.loadRaw = loadRaw;\n  repo.hasHash = hasHash;\n  repo.readRef = readRef;\n  repo.updateRef = updateRef;\n  repo.listRefs = listRefs;\n\n  function readRef(ref, callback) {\n    return makeAsync(function () {\n      return refs[ref];\n    }, callback);\n  }\n\n  function listRefs(prefix, callback) {\n    return makeAsync(function () {\n      var regex = prefix && new RegExp(\"^\" + prefix + \"[/$]\");\n      var out = {};\n      Object.keys(refs).forEach(function (name) {\n        if (regex && !regex.test(name)) return;\n        out[name] = refs[name];\n      });\n      return out;\n    }, callback);\n  }\n\n  function updateRef(ref, hash, callback) {\n    return makeAsync(function () {\n      return (refs[ref] = hash);\n    }, callback);\n  }\n\n  function hasHash(hash, callback) {\n    return makeAsync(function () {\n      if (!isHash.test(hash)) hash = refs[hash];\n      return hash in objects;\n    }, callback);\n  }\n\n  function saveAs(type, body, callback) {\n    return makeAsync(function () {\n      var buffer = codec.frame({type:type,body:body});\n      var hash = sha1(buffer);\n      objects[hash] = buffer;\n      return hash;\n    }, callback);\n  }\n\n  function saveRaw(hash, buffer, callback) {\n    return makeAsync(function () {\n      objects[hash] = buffer;\n    }, callback);\n  }\n\n  function loadAs(type, hash, callback) {\n    return makeAsync(function () {\n      if (!isHash.test(hash)) hash = refs[hash];\n      var buffer = objects[hash];\n      if (!buffer) return [];\n      var obj = codec.deframe(buffer, true);\n      if (obj.type !== type) throw new TypeError(\"Type mismatch\");\n      return obj.body;\n    }, callback);\n  }\n\n  function loadRaw(hash, callback) {\n    return makeAsync(function () {\n      return objects[hash];\n    }, callback);\n  }\n}\n\nfunction makeAsync(fn, callback) {\n  if (!callback) return makeAsync.bind(null, fn);\n  defer(function () {\n    var out;\n    try { out = fn(); }\n    catch (err) { return callback(err); }\n    callback(null, out);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/pack-ops.js":"\"use strict\";\n\nvar sha1 = require('git-sha1');\nvar applyDelta = require('../lib/apply-delta.js');\nvar codec = require('../lib/object-codec.js');\nvar decodePack = require('../lib/pack-codec.js').decodePack;\nvar encodePack = require('../lib/pack-codec.js').encodePack;\nvar makeChannel = require('culvert');\n\nmodule.exports = function (repo) {\n  // packChannel is a writable culvert channel {put,drain} containing raw packfile binary data\n  // opts can contain \"onProgress\" or \"onError\" hook functions.\n  // callback will be called with a list of all unpacked hashes on success.\n  repo.unpack = unpack; // (packChannel, opts) => hashes\n\n  // hashes is an array of hashes to pack\n  // packChannel will be a readable culvert channel {take} containing raw packfile binary data\n  repo.pack = pack;     // (hashes, opts) => packChannel\n};\n\nfunction unpack(packChannel, opts, callback) {\n  /*jshint validthis:true*/\n  if (!callback) return unpack.bind(this, packChannel, opts);\n\n  packChannel = applyParser(packChannel, decodePack, callback);\n\n  var repo = this;\n\n  var version, num, numDeltas = 0, count = 0, countDeltas = 0;\n  var done, startDeltaProgress = false;\n\n  // hashes keyed by offset for ofs-delta resolving\n  var hashes = {};\n  // key is hash, boolean is cached \"has\" value of true or false\n  var has = {};\n  // key is hash we're waiting for, value is array of items that are waiting.\n  var pending = {};\n\n  return packChannel.take(onStats);\n\n  function onDone(err) {\n    if (done) return;\n    done = true;\n    if (err) return callback(err);\n    return callback(null, values(hashes));\n  }\n\n  function onStats(err, stats) {\n    if (err) return onDone(err);\n    version = stats.version;\n    num = stats.num;\n    packChannel.take(onRead);\n  }\n\n  function objectProgress(more) {\n    if (!more) startDeltaProgress = true;\n    var percent = Math.round(count / num * 100);\n    return opts.onProgress(\"Receiving objects: \" + percent + \"% (\" + (count++) + \"/\" + num + \")   \" + (more ? \"\\r\" : \"\\n\"));\n  }\n\n  function deltaProgress(more) {\n    if (!startDeltaProgress) return;\n    var percent = Math.round(countDeltas / numDeltas * 100);\n    return opts.onProgress(\"Applying deltas: \" + percent + \"% (\" + (countDeltas++) + \"/\" + numDeltas + \")   \" + (more ? \"\\r\" : \"\\n\"));\n  }\n\n  function onRead(err, item) {\n    if (err) return onDone(err);\n    if (opts.onProgress) objectProgress(item);\n    if (item === undefined) return onDone();\n    if (item.size !== item.body.length) {\n      return onDone(new Error(\"Body size mismatch\"));\n    }\n    if (item.type === \"ofs-delta\") {\n      numDeltas++;\n      item.ref = hashes[item.offset - item.ref];\n      return resolveDelta(item);\n    }\n    if (item.type === \"ref-delta\") {\n      numDeltas++;\n      return checkDelta(item);\n    }\n    return saveValue(item);\n  }\n\n  function resolveDelta(item) {\n    if (opts.onProgress) deltaProgress();\n    return repo.loadRaw(item.ref, function (err, buffer) {\n      if (err) return onDone(err);\n      if (!buffer) return onDone(new Error(\"Missing base image at \" + item.ref));\n      var target = codec.deframe(buffer);\n      item.type = target.type;\n      item.body = applyDelta(item.body, target.body);\n      return saveValue(item);\n    });\n  }\n\n  function checkDelta(item) {\n    var hasTarget = has[item.ref];\n    if (hasTarget === true) return resolveDelta(item);\n    if (hasTarget === false) return enqueueDelta(item);\n    return repo.hasHash(item.ref, function (err, value) {\n      if (err) return onDone(err);\n      has[item.ref] = value;\n      if (value) return resolveDelta(item);\n      return enqueueDelta(item);\n    });\n  }\n\n  function saveValue(item) {\n    var buffer = codec.frame(item);\n    var hash = sha1(buffer);\n    hashes[item.offset] = hash;\n    has[hash] = true;\n    if (hash in pending) {\n      // I have yet to come across a pack stream that actually needs this.\n      // So I will only implement it when I have concrete data to test against.\n      console.error({\n        list: pending[hash],\n        item: item\n      });\n      throw \"TODO: pending value was found, resolve it\";\n    }\n    return repo.saveRaw(hash, buffer, onSave);\n  }\n\n  function onSave(err) {\n    if (err) return callback(err);\n    packChannel.take(onRead);\n  }\n\n  function enqueueDelta(item) {\n    var list = pending[item.ref];\n    if (!list) pending[item.ref] = [item];\n    else list.push(item);\n    packChannel.take(onRead);\n  }\n\n}\n\n// TODO: Implement delta refs to reduce stream size\nfunction pack(hashes, opts, callback) {\n  /*jshint validthis:true*/\n  if (!callback) return pack.bind(this, hashes, opts);\n  var repo = this;\n  var i = 0, first = true, done = false;\n  return callback(null, applyParser({ take: take }, encodePack));\n\n  function take(callback) {\n    if (done) return callback();\n    if (first) return readFirst(callback);\n    var hash = hashes[i++];\n    if (hash === undefined) {\n      return callback();\n    }\n    repo.loadRaw(hash, function (err, buffer) {\n      if (err) return callback(err);\n      if (!buffer) return callback(new Error(\"Missing hash: \" + hash));\n      // Reframe with pack format header\n      callback(null, codec.deframe(buffer));\n    });\n  }\n\n  function readFirst(callback) {\n    first = false;\n    callback(null, {num: hashes.length});\n  }\n}\n\nfunction values(object) {\n  var keys = Object.keys(object);\n  var length = keys.length;\n  var out = new Array(length);\n  for (var i = 0; i < length; i++) {\n    out[i] = object[keys[i]];\n  }\n  return out;\n}\n\n\nfunction applyParser(stream, parser, onError) {\n  var extra = makeChannel();\n  extra.put = parser(extra.put);\n  stream.take(onData);\n\n  function onData(err, item) {\n    if (err) return onError(err);\n    var more;\n    try { more = extra.put(item); }\n    catch (err) { return onError(err); }\n    if (more) stream.take(onData);\n    else extra.drain(onDrain);\n  }\n\n  function onDrain(err) {\n    if (err) return onError(err);\n    stream.take(onData);\n  }\n\n  return { take: extra.take };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/path-to-entry.js":"var cache = require('./mem-cache').cache;\nvar modes = require('../lib/modes');\n\nmodule.exports = function (repo) {\n  repo.pathToEntry = pathToEntry;\n};\n\nfunction pathToEntry(rootTree, path, callback) {\n  if (!callback) return pathToEntry.bind(this, rootTree, path);\n  var repo = this;\n  var mode = modes.tree;\n  var hash = rootTree;\n  var parts = path.split(\"/\").filter(Boolean);\n  var index = 0;\n  var cached;\n  loop();\n  function loop() {\n    while (index < parts.length) {\n      if (mode === modes.tree) {\n        cached = cache[hash];\n        if (!cached) return repo.loadAs(\"tree\", hash, onLoad);\n        var entry = cached[parts[index]];\n        if (!entry) return callback();\n        mode = entry.mode;\n        hash = entry.hash;\n        index++;\n        continue;\n      }\n      if (modes.isFile(mode)) return callback();\n      return callback(null, {\n        last: {\n          mode: mode,\n          hash: hash,\n          path: parts.slice(0, index).join(\"/\"),\n          rest: parts.slice(index).join(\"/\"),\n        }\n      });\n    }\n    callback(null, {\n      mode: mode,\n      hash: hash\n    });\n  }\n\n  function onLoad(err, value) {\n    if (!value) return callback(err || new Error(\"Missing object: \" + hash));\n    cache[hash] = value;\n    loop();\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/read-combiner.js":"\"use strict\";\n\n// This replaces loadAs with a version that batches concurrent requests for\n// the same hash.\nmodule.exports = function (repo) {\n  var pendingReqs = {};\n\n  var loadAs = repo.loadAs;\n  repo.loadAs = newLoadAs;\n\n  function newLoadAs(type, hash, callback) {\n    if (!callback) return newLoadAs.bind(null, type, hash);\n    var list = pendingReqs[hash];\n    if (list) {\n      if (list.type !== type) callback(new Error(\"Type mismatch\"));\n      else list.push(callback);\n      return;\n    }\n    list = pendingReqs[hash] = [callback];\n    list.type = type;\n    loadAs.call(repo, type, hash, function () {\n      delete pendingReqs[hash];\n      for (var i = 0, l = list.length; i < l; i++) {\n        list[i].apply(this, arguments);\n      }\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/sync.js":"\"use strict\";\n\nvar modes = require('../lib/modes');\n\nmodule.exports = function (local, remote) {\n  local.fetch = fetch;\n  local.send = send;\n  local.readRemoteRef = remote.readRef.bind(remote);\n  local.updateRemoteRef = remote.updateRef.bind(remote);\n\n  function fetch(ref, depth, callback) {\n    if (!callback) return fetch.bind(local, ref, depth);\n    sync(local, remote, ref, depth, callback);\n  }\n\n  function send(ref, callback) {\n    if (!callback) return send.bind(local, ref);\n    sync(remote, local, ref, Infinity, callback);\n  }\n};\n\n// Download remote ref with depth\n// Make sure to use Infinity for depth on github mounts or anything that\n// doesn't allow shallow clones.\nfunction sync(local, remote, ref, depth, callback) {\n  if (typeof ref !== \"string\") throw new TypeError(\"ref must be string\");\n  if (typeof depth !== \"number\") throw new TypeError(\"depth must be number\");\n\n  var hasCache = {};\n\n  remote.readRef(ref, function (err, hash) {\n    if (!hash) return callback(err);\n    importCommit(hash, depth, function (err) {\n      if (err) return callback(err);\n      callback(null, hash);\n    });\n  });\n\n  // Caching has check.\n  function check(type, hash, callback) {\n    if (typeof type !== \"string\") throw new TypeError(\"type must be string\");\n    if (typeof hash !== \"string\") throw new TypeError(\"hash must be string\");\n    if (hasCache[hash]) return callback(null, true);\n    local.hasHash(hash, function (err, has) {\n      if (err) return callback(err);\n      hasCache[hash] = has;\n      callback(null, has);\n    });\n  }\n\n  function importCommit(hash, depth, callback) {\n    check(\"commit\", hash, onCheck);\n\n    function onCheck(err, has) {\n      if (err || has) return callback(err);\n      remote.loadAs(\"commit\", hash, onLoad);\n    }\n\n    function onLoad(err, commit) {\n      if (!commit) return callback(err || new Error(\"Missing commit \" + hash));\n      var i = 0;\n      importTree(commit.tree, onImport);\n\n      function onImport(err) {\n        if (err) return callback(err);\n        if (i >= commit.parents.length || depth <= 1) {\n          return local.saveAs(\"commit\", commit, onSave);\n        }\n        importCommit(commit.parents[i++], depth - 1, onImport);\n      }\n    }\n\n    function onSave(err, newHash) {\n      if (err) return callback(err);\n      if (newHash !== hash) {\n        return callback(new Error(\"Commit hash mismatch \" + hash + \" != \" + newHash));\n      }\n      hasCache[hash] = true;\n      callback();\n    }\n  }\n\n  function importTree(hash, callback) {\n    check(\"tree\", hash, onCheck);\n\n    function onCheck(err, has) {\n      if (err || has) return callback(err);\n      remote.loadAs(\"tree\", hash, onLoad);\n    }\n\n    function onLoad(err, tree) {\n      if (!tree) return callback(err || new Error(\"Missing tree \" + hash));\n      var i = 0;\n      var names = Object.keys(tree);\n      onImport();\n\n      function onImport(err) {\n        if (err) return callback(err);\n        if (i >= names.length) {\n          return local.saveAs(\"tree\", tree, onSave);\n        }\n        var name = names[i++];\n        var entry = tree[name];\n        if (modes.isBlob(entry.mode)) {\n          return importBlob(entry.hash, onImport);\n        }\n        if (entry.mode === modes.tree) {\n          return importTree(entry.hash, onImport);\n        }\n        // Skip others.\n        onImport();\n      }\n    }\n\n    function onSave(err, newHash) {\n      if (err) return callback(err);\n      if (newHash !== hash) {\n        return callback(new Error(\"Tree hash mismatch \" + hash + \" != \" + newHash));\n      }\n      hasCache[hash] = true;\n      callback();\n    }\n  }\n\n  function importBlob(hash, callback) {\n    check(\"blob\", hash, onCheck);\n\n    function onCheck(err, has) {\n      if (err || has) return callback(err);\n      remote.loadAs(\"blob\", hash, onLoad);\n    }\n\n    function onLoad(err, blob) {\n      if (!blob) return callback(err || new Error(\"Missing blob \" + hash));\n      local.saveAs(\"blob\", blob, onSave);\n    }\n\n    function onSave(err, newHash) {\n      if (err) return callback(err);\n      if (newHash !== hash) {\n        return callback(new Error(\"Blob hash mismatch \" + hash + \" != \" + newHash));\n      }\n      hasCache[hash] = true;\n      callback();\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/walkers.js":"var modes = require('../lib/modes.js');\n\nmodule.exports = function (repo) {\n  repo.logWalk = logWalk;   // (ref) => stream<commit>\n  repo.treeWalk = treeWalk; // (treeHash) => stream<object>\n};\nmodule.exports.walk = walk;\n\nfunction logWalk(ref, callback) {\n  if (!callback) return logWalk.bind(this, ref);\n  var last, seen = {};\n  var repo = this;\n  if (!repo.readRef) return onShallow();\n  return repo.readRef(\"shallow\", onShallow);\n\n  function onShallow(err, shallow) {\n    last = shallow;\n    resolveRef(repo, ref, onHash);\n  }\n\n  function onHash(err, hash) {\n    if (err) return callback(err);\n    return repo.loadAs(\"commit\", hash, function (err, commit) {\n      if (commit === undefined) return callback(err);\n      commit.hash = hash;\n      seen[hash] = true;\n      return callback(null, walk(commit, scan, loadKey, compare));\n    });\n  }\n\n  function scan(commit) {\n    if (last === commit) return [];\n    return commit.parents.filter(function (hash) {\n      return !seen[hash];\n    });\n  }\n\n  function loadKey(hash, callback) {\n    return repo.loadAs(\"commit\", hash, function (err, commit) {\n      if (!commit) return callback(err || new Error(\"Missing commit \" + hash));\n      commit.hash = hash;\n      if (hash === last) commit.last = true;\n      return callback(null, commit);\n    });\n  }\n\n}\n\nfunction compare(commit, other) {\n  return commit.author.date < other.author.date;\n}\n\nfunction treeWalk(hash, callback) {\n  if (!callback) return treeWalk.bind(this, hash);\n  var repo = this;\n  return repo.loadAs(\"tree\", hash, onTree);\n\n  function onTree(err, body) {\n    if (!body) return callback(err || new Error(\"Missing tree \" + hash));\n    var tree = {\n      mode: modes.tree,\n      hash: hash,\n      body: body,\n      path: \"/\"\n    };\n    return callback(null, walk(tree, treeScan, treeLoadKey, treeCompare));\n  }\n\n  function treeLoadKey(entry, callback) {\n    if (entry.mode !== modes.tree) return callback(null, entry);\n    var type = modes.toType(entry.mode);\n    return repo.loadAs(type, entry.hash, function (err, body) {\n      if (err) return callback(err);\n      entry.body = body;\n      return callback(null, entry);\n    });\n  }\n\n}\n\nfunction treeScan(object) {\n  if (object.mode !== modes.tree) return [];\n  var tree = object.body;\n  return Object.keys(tree).map(function (name) {\n    var entry = tree[name];\n    var path = object.path + name;\n    if (entry.mode === modes.tree) path += \"/\";\n    return {\n      mode: entry.mode,\n      hash: entry.hash,\n      path: path\n    };\n  });\n}\n\nfunction treeCompare(first, second) {\n  return first.path < second.path;\n}\n\nfunction resolveRef(repo, hashish, callback) {\n  if (/^[0-9a-f]{40}$/.test(hashish)) {\n    return callback(null, hashish);\n  }\n  repo.readRef(hashish, function (err, hash) {\n    if (!hash) return callback(err || new Error(\"Bad ref \" + hashish));\n    callback(null, hash);\n  });\n}\n\nfunction walk(seed, scan, loadKey, compare) {\n  var queue = [seed];\n  var working = 0, error, cb;\n  return {read: read, abort: abort};\n\n  function read(callback) {\n    if (!callback) return read;\n    if (cb) return callback(new Error(\"Only one read at a time\"));\n    if (working) { cb = callback; return; }\n    var item = queue.shift();\n    if (!item) return callback();\n    try { scan(item).forEach(onKey); }\n    catch (err) { return callback(err); }\n    return callback(null, item);\n  }\n\n  function abort(callback) { return callback(); }\n\n  function onError(err) {\n    if (cb) {\n      var callback = cb; cb = null;\n      return callback(err);\n    }\n    error = err;\n  }\n\n  function onKey(key) {\n    working++;\n    loadKey(key, onItem);\n  }\n\n  function onItem(err, item) {\n    working--;\n    if (err) return onError(err);\n    var index = queue.length;\n    while (index && compare(item, queue[index - 1])) index--;\n    queue.splice(index, 0, item);\n    if (!working && cb) {\n      var callback = cb; cb = null;\n      return read(callback);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/mixins/websql-db.js":"\"use strict\";\n\nvar codec = require('../lib/object-codec.js');\nvar bodec = require('bodec');\nvar inflate = require('../lib/inflate');\nvar deflate = require('../lib/deflate');\n\nvar sha1 = require('git-sha1');\nvar modes = require('../lib/modes.js');\nvar db;\n\nmixin.init = init;\n\nmixin.loadAs = loadAs;\nmixin.saveAs = saveAs;\nmixin.loadRaw = loadRaw;\nmixin.saveRaw = saveRaw;\nmodule.exports = mixin;\n\nfunction mixin(repo, prefix) {\n  if (!prefix) throw new Error(\"Prefix required\");\n  repo.refPrefix = prefix;\n  repo.saveAs = saveAs;\n  repo.saveRaw = saveRaw;\n  repo.loadAs = loadAs;\n  repo.loadRaw = loadRaw;\n  repo.readRef = readRef;\n  repo.updateRef = updateRef;\n  repo.hasHash = hasHash;\n}\n\nfunction init(callback) {\n\n  db = openDatabase('tedit', '1.0', 'tedit local data', 10 * 1024 * 1024);\n  db.transaction(function (tx) {\n    tx.executeSql(\n      'CREATE TABLE IF NOT EXISTS objects (hash unique, body blob)'\n    );\n    tx.executeSql(\n      'CREATE TABLE IF NOT EXISTS refs (path unique, value text)'\n    );\n  }, function () {\n    console.error(arguments);\n    callback(new Error(\"Problem initializing database\"));\n  }, function () {\n    callback();\n  });\n}\n\nfunction saveAs(type, body, callback) {\n  /*jshint: validthis: true */\n  if (!callback) return saveAs.bind(this, type, body);\n  var hash, buffer;\n  try {\n    buffer = codec.frame({type:type,body:body});\n    hash = sha1(buffer);\n  }\n  catch (err) { return callback(err); }\n  this.saveRaw(hash, buffer, callback);\n}\n\nfunction saveRaw(hash, buffer, callback) {\n  /*jshint: validthis: true */\n  if (!callback) return saveRaw.bind(this, hash, buffer);\n  var sql = 'INSERT INTO objects (hash, body) VALUES (?, ?)';\n  db.transaction(function (tx) {\n    var text;\n    try {\n      text = bodec.toBase64(deflate(buffer));\n    }\n    catch (err) {\n      return callback(err);\n    }\n    tx.executeSql(sql, [hash, text], function () {\n      callback(null, hash);\n    });\n  });\n}\n\nfunction loadAs(type, hash, callback) {\n  /*jshint: validthis: true */\n  if (!callback) return loadAs.bind(this, type, hash);\n  loadRaw(hash, function (err, buffer) {\n    if (!buffer) return callback(err);\n    var parts, body;\n    try {\n      parts = codec.deframe(buffer);\n      if (parts.type !== type) throw new Error(\"Type mismatch\");\n      body = codec.decoders[type](parts.body);\n    }\n    catch (err) {\n      return callback(err);\n    }\n    callback(null, body);\n  });\n}\n\nfunction loadRaw(hash, callback) {\n  /*jshint: validthis: true */\n  if (!callback) return loadRaw.bind(this, hash);\n  var sql = 'SELECT * FROM objects WHERE hash=?';\n  db.readTransaction(function (tx) {\n    tx.executeSql(sql, [hash], function (tx, result) {\n      if (!result.rows.length) return callback();\n      var item = result.rows.item(0);\n      var buffer;\n      try {\n        buffer = inflate(bodec.fromBase64(item.body));\n      }\n      catch (err) {\n        return callback(err);\n      }\n      callback(null, buffer);\n    }, function (tx, error) {\n      callback(new Error(error.message));\n    });\n  });\n}\n\nfunction hasHash(type, hash, callback) {\n  /*jshint: validthis: true */\n  loadAs(type, hash, function (err, value) {\n    if (err) return callback(err);\n    if (value === undefined) return callback(null, false);\n    if (type !== \"tree\") return callback(null, true);\n    var names = Object.keys(value);\n    next();\n    function next() {\n      if (!names.length) return callback(null, true);\n      var name = names.pop();\n      var entry = value[name];\n      hasHash(modes.toType(entry.mode), entry.hash, function (err, has) {\n        if (err) return callback(err);\n        if (has) return next();\n        callback(null, false);\n      });\n    }\n  });\n}\n\nfunction readRef(ref, callback) {\n  /*jshint: validthis: true */\n  var key = this.refPrefix + \"/\" + ref;\n  var sql = 'SELECT * FROM refs WHERE path=?';\n  db.transaction(function (tx) {\n    tx.executeSql(sql, [key], function (tx, result) {\n      if (!result.rows.length) return callback();\n      var item = result.rows.item(0);\n      callback(null, item.value);\n    }, function (tx, error) {\n      callback(new Error(error.message));\n    });\n  });\n}\n\nfunction updateRef(ref, hash, callback) {\n  /*jshint: validthis: true */\n  var key = this.refPrefix + \"/\" + ref;\n  var sql = 'INSERT INTO refs (path, value) VALUES (?, ?)';\n  db.transaction(function (tx) {\n    tx.executeSql(sql, [key, hash], function () {\n      callback();\n    }, function (tx, error) {\n      callback(new Error(error.message));\n    });\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/request-xhr.js":"\"use strict\";\n\nmodule.exports = request;\n\nfunction request(method, url, headers, body, callback) {\n  if (typeof body === \"function\") {\n    callback = body;\n    body = undefined;\n  }\n  if (!callback) {\n    return request.bind(null, method, url, headers, body);\n  }\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n  xhr.responseType = \"arraybuffer\";\n\n  Object.keys(headers).forEach(function (name) {\n    xhr.setRequestHeader(name, headers[name]);\n  });\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) return;\n    var resHeaders = {};\n    xhr.getAllResponseHeaders().trim().split(\"\\r\\n\").forEach(function (line) {\n      var index = line.indexOf(\":\");\n      resHeaders[line.substring(0, index).toLowerCase()] = line.substring(index + 1).trim();\n    });\n\n    callback(null, {\n      statusCode: xhr.status,\n      headers: resHeaders,\n      body: xhr.response && new Uint8Array(xhr.response)\n    });\n  };\n  xhr.send(body);\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/tcp-chrome-sockets.js":"\"use strict\";\n\nvar makeChannel = require('culvert');\nvar wrapHandler = require('../lib/wrap-handler');\nvar tcp = window.chrome.sockets.tcp;\nvar runtime = window.chrome.runtime;\n\nmodule.exports = connect;\n\nfunction connect(host, port, onError) {\n  port = port|0;\n  host = String(host);\n  if (!port || !host) throw new TypeError(\"host and port are required\");\n\n  onCreate = wrap(onCreate, onError);\n  onConnect = wrap(onConnect, onError);\n  onInfo = wrap(onInfo, onError);\n  onReceive = wrap(onReceive, onError);\n  onReceiveError = wrap(onReceiveError, onError);\n  onData = wrapHandler(onData, onError);\n  onWrite = wrap(onWrite, onError);\n\n  var paused = false;\n  var open = false;\n  var socketId;\n\n  var serverChannel = makeChannel();\n  var clientChannel = makeChannel();\n  var socket = {\n    put: serverChannel.put,\n    drain: serverChannel.drain,\n    take: clientChannel.take\n  };\n\n  tcp.onReceive.addListener(onReceive);\n  tcp.onReceiveError.addListener(onReceiveError);\n  tcp.create(onCreate);\n\n  return {\n    put: clientChannel.put,\n    drain: clientChannel.drain,\n    take: serverChannel.take\n  };\n\n  function onCreate(createInfo) {\n    socketId = createInfo.socketId;\n    tcp.connect(socketId, host, port, onConnect);\n  }\n\n  function onConnect(result) {\n    if (result < 0) throw new Error(runtime.lastError.message + \" Connection error\");\n    tcp.getInfo(socketId, onInfo);\n  }\n\n  function onInfo(socketInfo) {\n    if (!socketInfo.connected) {\n      throw new Error(\"Connection failed\");\n    }\n    open = true;\n    socket.take(onData);\n  }\n\n  function onReceive(info) {\n    if (info.socketId !== socketId) return;\n    if (socket.put(new Uint8Array(info.data)) || paused) return;\n    paused = true;\n    tcp.setPaused(socketId, true);\n    socket.drain(onDrain);\n  }\n\n  function onDrain() {\n    if (!paused) return;\n    paused = false;\n    if (open) tcp.setPaused(socketId, false);\n  }\n\n  function onReceiveError(info) {\n    if (info.socketId !== socketId) return;\n    open = false;\n    tcp.close(socketId);\n    socket.put();\n    // TODO: find a way to tell close and error apart.\n    // throw new Error(\"Code \" + info.resultCode + \" error while receiving.\");\n  }\n\n  function onData(data) {\n    tcp.send(socketId, data.buffer, onWrite);\n  }\n\n  function onWrite(info) {\n    if (info.resultCode < 0) {\n      throw new Error(runtime.lastError.message + \" Error writing.\");\n    }\n    socket.take(onData);\n  }\n}\n\n\nfunction wrap(fn, onError) {\n  return function () {\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (err) {\n      onError(err);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/tcp-node.js":"\"use strict\";\n\nvar makeChannel = require('culvert');\nvar wrapHandler = require('../lib/wrap-handler');\nvar net = require('net');\n\nmodule.exports = connect;\n\nfunction connect(host, port, onError) {\n  port = port|0;\n  host = String(host);\n  if (!port || !host) throw new TypeError(\"host and port are required\");\n\n  // Wrap event handlers from node stream\n  onConnect = wrap(onConnect, onError);\n  pump = wrap(pump, onError);\n  onEnd = wrap(onEnd, onError);\n  onDrain = wrap(onDrain, onError);\n\n  // Wrap event handlers from culvert socket\n  onTake = wrapHandler(onTake, onError);\n\n  var serverChannel = makeChannel();\n  var clientChannel = makeChannel();\n  var socket = {\n    put: serverChannel.put,\n    drain: serverChannel.drain,\n    take: clientChannel.take\n  };\n\n  var client = net.connect({ host: host, port: port }, onConnect);\n  if (onError) client.on(\"error\", onError);\n\n  return {\n    put: clientChannel.put,\n    drain: clientChannel.drain,\n    take: serverChannel.take\n  };\n\n  function onConnect() {\n    socket.take(onTake);\n    client.on(\"end\", onEnd);\n    client.on(\"readable\", pump);\n    client.on(\"drain\", onDrain);\n    client.on(\"error\", onError);\n  }\n\n  function pump() {\n    var chunk;\n    do {\n      chunk = client.read();\n      if (!chunk) return;\n    } while (socket.put(chunk));\n    socket.drain(pump);\n  }\n\n  function onEnd() {\n    socket.put();\n  }\n\n  function onTake(data) {\n    if (data === undefined) {\n      client.end();\n    }\n    else if (client.write(data)) {\n      socket.take(onTake);\n    }\n  }\n\n  function onDrain() {\n    socket.take(onTake);\n  }\n\n}\n\nfunction wrap(fn, onError) {\n  return function () {\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (err) {\n      onError(err);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/tcp-ws-proxy.js":"\"use strict\";\n\nvar makeChannel = require('culvert');\nvar wrapHandler = require('../lib/wrap-handler');\n\nmodule.exports = function (proxyUrl) {\n  if (proxyUrl[proxyUrl.length - 1] !== \"/\") proxyUrl += \"/\";\n\n  return function connect(host, port, onError) {\n    port = port|0;\n    host = String(host);\n    if (!port || !host) throw new TypeError(\"host and port are required\");\n\n    onData = wrapHandler(onData, onError);\n\n    var serverChannel = makeChannel();\n    var clientChannel = makeChannel();\n    var socket = {\n      put: serverChannel.put,\n      drain: serverChannel.drain,\n      take: clientChannel.take\n    };\n\n    var connected = false;\n    var ws = new WebSocket(proxyUrl  + \"tcp/\" + host + \"/\" + port);\n    ws.binaryType = \"arraybuffer\";\n\n    ws.onopen = wrap(onOpen, onError);\n    ws.onclose = wrap(onClose, onError);\n    ws.onmessage = wrap(onMessage, onError);\n    ws.onerror = wrap(onWsError, onError);\n\n    return {\n      put: clientChannel.put,\n      drain: clientChannel.drain,\n      take: serverChannel.take\n    };\n\n    function onOpen() {\n      ws.send(\"connect\");\n    }\n\n    function onClose() {\n      socket.put();\n    }\n\n    function onMessage(evt) {\n      if (!connected && evt.data === \"connect\") {\n        connected = true;\n        socket.take(onData);\n        return;\n      }\n\n      socket.put(new Uint8Array(evt.data));\n    }\n\n    function onWsError() {\n      console.error(arguments);\n      throw new Error(\"Generic websocket error\");\n    }\n\n    function onData(chunk) {\n      ws.send(chunk.buffer);\n      socket.take(onData);\n    }\n\n  };\n};\n\nfunction wrap(fn, onError) {\n  return function () {\n    try {\n      return fn.apply(this, arguments);\n    }\n    catch (err) {\n      onError(err);\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/transport-http.js":"\"use strict\";\n\nvar makeChannel = require('culvert');\nvar bodec = require('bodec');\nvar pktLine = require('../lib/pkt-line');\nvar wrapHandler = require('../lib/wrap-handler');\n\nmodule.exports = function (request) {\n\n  return function httpTransport(gitUrl, username, password) {\n    // Send Auth header if username is set\n    var auth;\n    if (username) {\n      auth = \"Basic \" + btoa(username + \":\" + (password || \"\"));\n    }\n\n    return function (serviceName, onError) {\n\n      // Wrap our handler functions to route errors properly.\n      onResponse = wrapHandler(onResponse, onError);\n      onWrite = wrapHandler(onWrite, onError);\n      onResult = wrapHandler(onResult, onError);\n\n      // Create a duplex channel with transform for internal use.\n      var serverChannel = makeChannel();//0, \"server\");\n      var clientChannel = makeChannel();//0, \"client\");\n      var socket = {\n        put: serverChannel.put,\n        drain: serverChannel.drain,\n        take: clientChannel.take\n      };\n\n      // Send the initial request to start the connection.\n      var headers = {};\n      if (auth) headers.Authorization = auth;\n      request(\"GET\", gitUrl + \"/info/refs?service=\" + serviceName, headers, onResponse);\n\n      // Prep for later requests\n      var bodyParts = [];\n      var bodyWrite = pktLine.framer(function (chunk) {\n        bodyParts.push(chunk);\n      });\n      headers[\"Content-Type\"] = \"application/x-\" + serviceName + \"-request\";\n      socket.take(onWrite);\n\n      var verified = 0;\n      var parseResponse = pktLine.deframer(function (line) {\n        if (verified === 2) {\n          socket.put(line);\n        }\n        else if (verified === 0) {\n          if (line !== \"# service=\" + serviceName) {\n            throw new Error(\"Illegal service response\");\n          }\n          verified = 1;\n        }\n        else if (verified === 1) {\n          if (line !== null) {\n            throw new Error(\"Expected null after service name\");\n          }\n          verified = 2;\n        }\n      });\n\n      // Return the other half of the duplex channel for the protocol logic to use.\n      return {\n        put: clientChannel.put,\n        drain: clientChannel.drain,\n        take: serverChannel.take\n      };\n\n      function onResponse(res) {\n        if (res.statusCode !== 200) {\n          throw new Error(\"Invalid response: \" + res.statusCode);\n        }\n        if (res.headers[\"content-type\"] !== \"application/x-\" + serviceName + \"-advertisement\") {\n          throw new Error(\"Not a smart http git server\");\n        }\n        parseResponse(res.body);\n      }\n\n      function onWrite(item) {\n        if (item === undefined) return socket.put();\n        bodyWrite(item);\n        socket.take(onWrite);\n        if (item !== \"done\\n\" || !bodyParts.length) return;\n        var body = bodec.join(bodyParts);\n        bodyParts.length = 0;\n        request(\"POST\", gitUrl + \"/\" + serviceName, headers, body, onResult);\n      }\n\n      function onResult(res) {\n        if (res.statusCode !== 200) {\n          throw new Error(\"Invalid result: \" + res.statusCode);\n        }\n        if (res.headers[\"content-type\"] !== \"application/x-\" + serviceName + \"-result\") {\n          throw new Error(\"Not a smart http git server\");\n        }\n        parseResponse(res.body);\n      }\n    };\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-js-git/node_modules/js-git/net/transport-tcp.js":"\"use strict\";\n\nvar makeChannel = require('culvert');\nvar bodec = require('bodec');\nvar pktLine = require('../lib/pkt-line');\nvar wrapHandler = require('../lib/wrap-handler');\n\nmodule.exports = function (connect) {\n\n  return function tcpTransport(path, host, port) {\n    port = (port|0) || 9418;\n    if (!path || !host) throw new Error(\"path and host are required\");\n\n    return function (serviceName, onError) {\n\n      onData = wrapHandler(onData, onError);\n      onDrain = wrapHandler(onDrain, onError);\n\n      var socket = connect(host, port, onError);\n      var inter = makeChannel();\n      inter.put = pktLine.deframer(inter.put);\n\n      socket.put = pktLine.framer(socket.put);\n      var greeting = bodec.fromRaw(serviceName + \" \" + path + \"\\0host=\" + host + \"\\0\");\n      socket.put(greeting);\n\n      // Pipe socket to inter with backpressure\n      socket.take(onData);\n      function onData(chunk) {\n        if (inter.put(chunk)) {\n          socket.take(onData);\n        }\n        else {\n          inter.drain(onDrain);\n        }\n      }\n      function onDrain() {\n        socket.take(onData);\n      }\n\n      return {\n        put: socket.put,\n        drain: socket.drain,\n        take: inter.take\n      };\n    };\n  };\n};\n"}